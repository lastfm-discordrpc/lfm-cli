package main

import (
	"fmt"
	httpClient "github.com/bozd4g/go-http-client"
	log "github.com/sirupsen/logrus"
	"golang.org/x/exp/slices"
	"golang.org/x/net/html"
	"io"
	"strconv"
	"strings"
	"time"
)

const lastFmUrl = "https://www.last.fm/"

var lastFm = httpClient.New(lastFmUrl)

type scrobble struct {
	active        bool      // Whether the user is actively scrobbling
	name          string    // The name of the track
	artist        string    // The artist of the track
	album         string    // The album of the track
	loved         bool      // Whether the user loves the track
	dataId        string    // A unique ID used to identify the scrobble, generated by Last.FM
	dataTimestamp time.Time // When the user began scrobbling
	dataLink      string    // A link to the track (YouTube, etc.)
	dataLinkTitle string    // A description for the dataLink
	coverArtUrl   string    // A URL to the album cover art
}

var emptyScrobble = scrobble{
	active: false,
}

func searchHTMLAttribute(attributes []html.Attribute, name string) string {
	index := slices.IndexFunc(attributes, func(attribute html.Attribute) bool { return attribute.Key == name })
	if index < 0 {
		return ""
	}
	return attributes[index].Val
}

func getLatestSong(username string) scrobble {
	log.Traceln("Initiating request to Last.FM")
	request, err := lastFm.Get(fmt.Sprintf("user/%v/partial/recenttracks?ajax=1", username))
	requestStr := fmt.Sprintf("%#v", request)
	requestLogCtx := log.WithFields(log.Fields{
		"request": requestStr,
	})
	if err != nil {
		requestLogCtx.Warnln("Request could not form properly.")
		return emptyScrobble
	}

	response, err := lastFm.Do(request)
	if err != nil {
		requestLogCtx.Warnln("Request could not be done.")
		return emptyScrobble
	}

	responseLogCtx := log.WithFields(log.Fields{
		"request":  requestStr,
		"response": fmt.Sprintf("%#v", response),
	})
	responseStruct := response.Get()
	body := string(responseStruct.Body)
	code := responseStruct.StatusCode
	if code != 200 {
		responseLogCtx.Infof("Request returned invalid code.")
		return emptyScrobble
	}

	if !strings.Contains(body, "Scrobbling now") {
		log.Debug("No active scrobble detected.")
		return emptyScrobble
	}

	ioReader := strings.NewReader(strings.ReplaceAll(body, "\n", ""))
	tokenizer := html.NewTokenizer(ioReader)

	var keys []string
	var name string
	var artist string
	var album string
	var loved bool
	var dataId string
	var dataTime time.Time
	var dataLink string
	var dataLinkTitle string
	var coverArtUrl string

	for {
		tokenType := tokenizer.Next()

		// Error collection
		if tokenType == html.ErrorToken {
			err = tokenizer.Err()
			if err == io.EOF {
				break
			}

			log.Warnln("Error tokenizing HTML.")
		}

		if tokenType == html.StartTagToken {
			token := tokenizer.Token()

			if "thead" == token.Data { // Get keys for the map
				tokenizer.Next() // Table row
				for {            // Each header cell
					tokenType = tokenizer.Next()
					if tokenType == html.StartTagToken && "th" == tokenizer.Token().Data { // Each header
						tokenizer.Next()
						key := tokenizer.Token().Data
						trimmed := strings.TrimSpace(key)
						keys = append(keys, trimmed)
					}
					if tokenType == html.EndTagToken && "thead" == tokenizer.Token().Data { // At the end of thead
						break
					}
				}
			}

			if "tbody" == token.Data { // Get values for map
				// Get Table row representing the latest scrobble
				for {
					tokenType = tokenizer.Next()
					token = tokenizer.Token()
					if tokenType == html.StartTagToken && "tr" == token.Data {
						break
					}
				}

				attributes := token.Attr
				dataId = searchHTMLAttribute(attributes, "data-recenttrack-id")
				dataTimeString := searchHTMLAttribute(attributes, "data-timestamp")
				dataTimeInt64, err := strconv.ParseInt(dataTimeString, 10, 64)
				if err != nil {
					log.Println(err)
				}
				dataTime = time.Unix(dataTimeInt64, 0)
				index := 0

				for {

					tokenizerCopy := tokenizer

					if index == len(keys)-1 {
						break
					}

					tokenType = tokenizerCopy.Next()
					token = tokenizerCopy.Token()
					if tokenType == html.StartTagToken && "td" == token.Data {
						currentKey := keys[index]
						if currentKey == "Play" {
							for {
								tokenType = tokenizerCopy.Next()
								token = tokenizerCopy.Token()
								if tokenType == html.StartTagToken && "a" == token.Data {
									attributes = token.Attr
									dataLink = searchHTMLAttribute(attributes, "href")
									dataLinkTitle = searchHTMLAttribute(attributes, "title")
									break
								}

								if tokenType == html.EndTagToken && "td" == token.Data {
									dataLink = ""
									dataLinkTitle = ""
									break
								}
							}
						} else if currentKey == "Album" {
							for {
								tokenType = tokenizerCopy.Next()
								token = tokenizerCopy.Token()
								if tokenType == html.SelfClosingTagToken && "img" == token.Data {
									attributes = token.Attr
									album = html.UnescapeString(searchHTMLAttribute(attributes, "alt"))
									coverArtUrl = searchHTMLAttribute(attributes, "src")
									break
								}

								if tokenType == html.EndTagToken && "td" == token.Data {
									album = ""
									coverArtUrl = "lfm_logo"
									break
								}
							}
						} else if currentKey == "Loved" {
							for {
								tokenType = tokenizerCopy.Next()
								token = tokenizerCopy.Token()
								if tokenType == html.StartTagToken && "div" == token.Data {
									attributes = token.Attr
									lovedStringState := searchHTMLAttribute(attributes, "data-toggle-button-current-state")
									if lovedStringState == "loved" {
										loved = true
									} else {
										loved = false
									}
									break
								}

								if tokenType == html.EndTagToken && "td" == token.Data {
									loved = false
									break
								}
							}
						} else if currentKey == "Track name" {
							for {
								tokenType = tokenizerCopy.Next()
								token = tokenizerCopy.Token()
								if tokenType == html.StartTagToken && "a" == token.Data {
									// Get text token, which is after the start tag token
									tokenizerCopy.Next()
									token = tokenizerCopy.Token()
									name = html.UnescapeString(token.Data)
									break
								}

								if tokenType == html.EndTagToken && "td" == token.Data {
									name = "Unknown Song"
									log.Debugln("Song name was not found!")
									break
								}
							}
						} else if currentKey == "Artist name" {
							for {
								tokenType = tokenizerCopy.Next()
								token = tokenizerCopy.Token()
								if tokenType == html.StartTagToken && "a" == token.Data {
									// Get text token, which is after the start tag token
									tokenizerCopy.Next()
									token = tokenizerCopy.Token()
									artist = html.UnescapeString(token.Data)
									break
								}

								if tokenType == html.EndTagToken && "td" == token.Data {
									artist = "Unknown Song"
									log.Debugln("Song name was not found!")
									break
								}
							}
						}

						index++
					}
				}
			}
		}
	}

	detectedScrobble := scrobble{
		active:        true,
		name:          name,
		artist:        artist,
		album:         album,
		loved:         loved,
		dataId:        dataId,
		dataTimestamp: dataTime,
		dataLink:      dataLink,
		dataLinkTitle: dataLinkTitle,
		coverArtUrl:   coverArtUrl,
	}

	log.WithFields(log.Fields{"scrobble": detectedScrobble}).Traceln("Successfully tokenized new scrobble")
	return detectedScrobble

}
